// import express from 'express'
// import multer from 'multer'
// import cors from 'cors'
// import open from 'open'
// import path from 'path'
// import fs from 'fs/promises'
// import EventEmitter from 'events'
// import { port } from './config.js'
// import { readExcel, generateExcel } from './excelUtils.js'
// import { translateWithModel } from './aiClient.js'
// import { loadLexiconPrompts } from './lexiconUtils.js'

// const app = express()
// const __dirname = path.resolve()

// app.use(cors())
// app.use(express.static(path.join(__dirname, 'public')))

// const upload = multer({ dest: 'uploads/' })

// const progressEmitter = new EventEmitter()
// let lastProgress = { message: 'Waiting...', value: 0 }

// const emitProgress = (message, value) => {
//   lastProgress = { message, value }
//   progressEmitter.emit('update', lastProgress)
// }

// let lexiconPrompts = {}
// loadLexiconPrompts().then((loaded) => {
//   lexiconPrompts = loaded
// })

// const generatePrompt = (texts) => {
//   const formattedTexts = texts
//     .map((text, i) => `${i + 1}. "${text}"`)
//     .join('\n')

//   return `
// ููุชุฎุตุต ูู ูุชุงุจุฉ ุงููุญุชููุ ุงููุญู ุงูุนุฑุจูุ ุงูุชุฑุงููุจ ุงููุบููุฉุ ูุงูุชุฑุฌูุฉุ ูููุชู ูู ุชุฑุฌูุฉ ุงููุต ุงูุฅูุฌููุฒู ุงูููุนุทู ุฅูู ุนุฏุฉ ููุฌุงุช ุนุฑุจูุฉ ูุน ุงูุญูุงุธ ุนูู ุงููุนูู ุงูุฃุตูู ูุงูุณูุงู ุงููุงูู. ูุฌุจ ุฃู ุชููู ุงูุชุฑุฌูุฉ ุทุจูุนูุฉุ ุณูุณุฉุ ูููุงุณุจุฉ ุซูุงูููุง.

// ุชุฑุฌู ุงููุต ุฅูู ุงูููุฌุงุช ุงูุชุงููุฉ ูุน ุงุชุจุงุน ูุฐู ุงูุฅุฑุดุงุฏุงุช ุงููุญุฏุฏุฉ:

// 1. **ุงูุนุฑุจูุฉ ุงููุตุญู (MSA)**: ุญุงูุธ ุนูู ุงูููุงุนุฏ ุงููุบููุฉ ุงูุตุญูุญุฉ ูุงูุงุชุณุงู ุงููุบูู ูุน ุถูุงู ุฃู ุชููู ุงูุชุฑุฌูุฉ ููุธูุฉ ูุงุญุชุฑุงููุฉ.
// 2. **ุงูููุฌุฉ ุงูุฅูุงุฑุงุชูุฉ**: ุงุณุชุฎุฏู ููุฑุฏุงุช ูุฃุณููุจ ูุชุงุจุฉ ุฅูุงุฑุงุชู ุฃุตูู ุจุญูุซ ุชุนูุณ ุงูุทุฑููุฉ ุงูุทุจูุนูุฉ ุงูุชู ูุชุญุฏุซ ูููุชุจ ุจูุง ุงูุฅูุงุฑุงุชููู.
// 3. **ุงูููุฌุฉ ุงููุตุฑูุฉ**: ุงุฌุนู ุงููุต ุทุจูุนูุงู ูุจุฃุณููุจ ูุญุงุฏุซุฉ ููููุ ูุน ุงุณุชุฎุฏุงู ุงูุชุนุจูุฑุงุช ุงูุดุงุฆุนุฉ ูุงููุทู ุงูุฐู ูุนูุณ ุงููุบุฉ ุงููุญููุฉ ูู ูุตุฑ.
// 4. **ุงูููุฌุฉ ุงูุฃุฑุฏููุฉ**: ุงุณุชุฎุฏู ุงููููุงุช ูุงูุชุนุงุจูุฑ ุงูุดุงุฆุนุฉ ูู ููุฌุฉ ุนููุงู ุงูุญุถุฑูุฉ ูุฌุนู ุงูุชุฑุฌูุฉ ูุงุถุญุฉ ููุฃูููุฉ.
// 5. **ุงูููุฌุฉ ุงูููุณุทูููุฉ**: ุชุฑุฌู ุจุงูููุฌุฉ ุงูููุฏุณูุฉ ูุน ุงุณุชุฎุฏุงู ุชุนุงุจูุฑ ูุชุฑุงููุจ ุทุจูุนูุฉ ููุญูุงุธ ุนูู ุฃุตุงูุฉ ุงูููุฌุฉ.
// 6. **ุงูููุฌุฉ ุงูุณูุฑูุฉ**: ุงุณุชุฎุฏู ููุฌุฉ ุฏูุดู ุจููุฑุฏุงุช ูุชุฑุงููุจ ูุบููุฉ ุชุฌุนู ุงูุชุฑุฌูุฉ ูููููุฉ ูุทุจูุนูุฉ ููุฌูููุฑ ุงูุณูุฑู.
// 7. **ุงูููุฌุฉ ุงููุจูุงููุฉ**: ุชุฑุฌู ุจููุฌุฉ ุดุจุงุจ ุจูุฑูุชุ ูุน ุงูุญูุงุธ ุนูู ุณูุงุณุฉ ุงูุชุนุจูุฑ ูุงููุฑููุฉุ ูุชุฌูุจ ุงูุฌูู ุงูุซูููุฉ ุฃู ุงููุนูุฏุฉ ุจุดูู ุฒุงุฆุฏ.

// ุฅุฐุง ูุงู ููุงู ุชุนุจูุฑ ูุดุชุฑู ุจูู ุฃูุซุฑ ูู ููุฌุฉุ ูุญุงูุธ ุนูู ุงูุงุชุณุงู ูู ุงูุชุฑุฌูุฉ. ูุฅูุงุ ุนุฏูู ุงูุชุฑุฌูุฉ ุจุญูุซ ุชุนูุณ ูู ููุฌุฉ ุจุฏูุฉ.

// **ููู ุฌุฏูุง**: ูุง ุชูุถู ุงุณู ุงูููุฌุฉ ุฏุงุฎู ุงูุชุฑุฌูุฉ ููุณูุง (ูุซู: "ุจุงููุตุฑู" ุฃู "ุจุงูููุฌุฉ ุงูุฃุฑุฏููุฉ"). ููุท ูุฏูู ุงูุชุฑุฌูุฉ ูุจุงุดุฑุฉ ุจุฏูู ููุฏูุงุช ุฃู ุดุฑูุญุงุช.

// ${lexiconPrompts.msa || ''}
// ${lexiconPrompts.emirati || ''}
// ${lexiconPrompts.egyptian || ''}
// ${lexiconPrompts.jordanian || ''}
// ${lexiconPrompts.palestinian || ''}
// ${lexiconPrompts.syrian || ''}
// ${lexiconPrompts.lebanese || ''}

// ุชุฑุฌู ุงููุต ุงูุชุงูู:

// ${formattedTexts}

// ูุฏู ุงูุชุฑุฌูุงุช ููููุง ููุฐุง ุงูุชูุณูู ุจุงูุถุจุท:

// 1. **ุงูุนุฑุจูุฉ ุงููุตุญู**: [ุงูุชุฑุฌูุฉ]
//    **ุงูุฅูุงุฑุงุชูุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงููุตุฑูุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงูุฃุฑุฏููุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงูููุณุทูููุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงูุณูุฑูุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงููุจูุงููุฉ**: [ุงูุชุฑุฌูุฉ]
// `
// }

// const parseTranslations = (text) => {
//   const blocks = text.trim().split(/\n\n+/)
//   return blocks.map((block) => {
//     const lines = block.split('\n')
//     return {
//       msa: lines[0]?.replace('**ุงูุนุฑุจูุฉ ุงููุตุญู**: ', '').trim(),
//       emirati: lines[1]?.replace('**ุงูุฅูุงุฑุงุชูุฉ**: ', '').trim(),
//       egyptian: lines[2]?.replace('**ุงููุตุฑูุฉ**: ', '').trim(),
//       jordanian: lines[3]?.replace('**ุงูุฃุฑุฏููุฉ**: ', '').trim(),
//       palestinian: lines[4]?.replace('**ุงูููุณุทูููุฉ**: ', '').trim(),
//       syrian: lines[5]?.replace('**ุงูุณูุฑูุฉ**: ', '').trim(),
//       lebanese: lines[6]?.replace('**ุงููุจูุงููุฉ**: ', '').trim(),
//     }
//   })
// }

// // Progress polling endpoint
// app.get('/progress', (req, res) => {
//   res.json(lastProgress)
// })

// app.post('/upload', upload.single('file'), async (req, res) => {
//   try {
//     emitProgress('Uploading file...', 10)

//     const inputFilePath = req.file.path
//     const { headers, rows } = await readExcel(inputFilePath)

//     emitProgress('Reading Excel data...', 20)

//     const batchSize = 8
//     const totalBatches = Math.ceil(rows.length / batchSize)
//     let batch = []
//     let batchIndexes = []
//     let batchNum = 0

//     for (let i = 0; i < rows.length; i++) {
//       if (rows[i]['English']) {
//         batch.push(rows[i]['English'])
//         batchIndexes.push(i)

//         if (batch.length === batchSize || i === rows.length - 1) {
//           emitProgress(
//             `Translating batch ${batchNum + 1} of ${totalBatches}...`,
//             30 + Math.round((batchNum / totalBatches) * 50)
//           )

//           const prompt = generatePrompt(batch)
//           const messages = [
//             { role: 'system', content: 'ุฃูุช ูุณุงุนุฏ ูุบูู ูุชุฎุตุต ูู ุงูุชุฑุฌูุฉ.' },
//             { role: 'user', content: prompt },
//           ]

//           const responseText = await translateWithModel('qwen_2', messages)
//           // Change to openai, meta_1, meta_2,meta_3, qwen_2_5, qwen_2, deepseek as needed
//           const translations = parseTranslations(responseText)

//           batchIndexes.forEach((index, j) => {
//             const tr = translations[j]
//             if (tr) {
//               rows[index]['MSA'] = tr.msa
//               rows[index]['Emirati'] = tr.emirati
//               rows[index]['Egyptian'] = tr.egyptian
//               rows[index]['Jordanian'] = tr.jordanian
//               rows[index]['Palestinian'] = tr.palestinian
//               rows[index]['Syrian'] = tr.syrian
//               rows[index]['Lebanese'] = tr.lebanese
//             }
//           })

//           batch = []
//           batchIndexes = []
//           batchNum++
//         }
//       }
//     }

//     emitProgress('Generating translated file...', 90)

//     const outputFilePath = await generateExcel(
//       headers,
//       rows,
//       req.file.originalname
//     )

//     emitProgress('Translation complete!', 100)

//     res.download(outputFilePath, async (err) => {
//       if (err) console.error('Error sending file:', err)
//       await fs.unlink(inputFilePath)
//       await fs.unlink(outputFilePath)
//     })
//   } catch (err) {
//     console.error('โ Error processing file:', err.message)
//     emitProgress('Error during processing.', 0)
//     res.status(500).send('Server error')
//   }
// })

// app.listen(port, async () => {
//   console.log(`๐ Server running at http://localhost:${port}`)
//   await open(`http://localhost:${port}`)
// })

// import express from 'express'
// import multer from 'multer'
// import cors from 'cors'
// import open from 'open'
// import path from 'path'
// import fs from 'fs/promises'
// import EventEmitter from 'events'
// import { port } from './config.js'
// import { readExcel, generateExcel } from './excelUtils.js'
// import { translateWithModel } from './aiClient.js'
// import { loadLexiconPrompts } from './lexiconUtils.js'

// const app = express()
// const __dirname = path.resolve()

// app.use(cors())
// app.use(express.static(path.join(__dirname, 'public')))

// const upload = multer({ dest: 'uploads/' })

// const progressEmitter = new EventEmitter()
// let lastProgress = { message: 'Waiting...', value: 0 }

// const logFilePath = path.join(__dirname, 'server.log')
// const logToFile = async (message) => {
//   const timestamp = new Date().toISOString()
//   try {
//     await fs.appendFile(logFilePath, `[${timestamp}] ${message}\n`)
//   } catch (err) {
//     console.error('Error writing log:', err)
//   }
// }

// const emitProgress = (message, value) => {
//   lastProgress = { message, value }
//   progressEmitter.emit('update', lastProgress)
//   logToFile(`Progress update: ${message} (${value}%)`)
// }

// let lexiconPrompts = {}
// loadLexiconPrompts().then((loaded) => {
//   lexiconPrompts = loaded
//   logToFile('Lexicon prompts loaded.')
// })

// const generatePrompt = (texts) => {
//   const formattedTexts = texts
//     .map((text, i) => `${i + 1}. "${text}"`)
//     .join('\n')

//   return `
// ููุชุฎุตุต ูู ูุชุงุจุฉ ุงููุญุชููุ ุงููุญู ุงูุนุฑุจูุ ุงูุชุฑุงููุจ ุงููุบููุฉุ ูุงูุชุฑุฌูุฉุ ูููุชู ูู ุชุฑุฌูุฉ ุงููุต ุงูุฅูุฌููุฒู ุงูููุนุทู ุฅูู ุนุฏุฉ ููุฌุงุช ุนุฑุจูุฉ ูุน ุงูุญูุงุธ ุนูู ุงููุนูู ุงูุฃุตูู ูุงูุณูุงู ุงููุงูู. ูุฌุจ ุฃู ุชููู ุงูุชุฑุฌูุฉ ุทุจูุนูุฉุ ุณูุณุฉุ ูููุงุณุจุฉ ุซูุงูููุง.

// ุชุฑุฌู ุงููุต ุฅูู ุงูููุฌุงุช ุงูุชุงููุฉ ูุน ุงุชุจุงุน ูุฐู ุงูุฅุฑุดุงุฏุงุช ุงููุญุฏุฏุฉ:

// 1. **ุงูุนุฑุจูุฉ ุงููุตุญู (MSA)**: ุญุงูุธ ุนูู ุงูููุงุนุฏ ุงููุบููุฉ ุงูุตุญูุญุฉ ูุงูุงุชุณุงู ุงููุบูู ูุน ุถูุงู ุฃู ุชููู ุงูุชุฑุฌูุฉ ููุธูุฉ ูุงุญุชุฑุงููุฉ.
// 2. **ุงูููุฌุฉ ุงูุฅูุงุฑุงุชูุฉ**: ุงุณุชุฎุฏู ููุฑุฏุงุช ูุฃุณููุจ ูุชุงุจุฉ ุฅูุงุฑุงุชู ุฃุตูู ุจุญูุซ ุชุนูุณ ุงูุทุฑููุฉ ุงูุทุจูุนูุฉ ุงูุชู ูุชุญุฏุซ ูููุชุจ ุจูุง ุงูุฅูุงุฑุงุชููู.
// 3. **ุงูููุฌุฉ ุงููุตุฑูุฉ**: ุงุฌุนู ุงููุต ุทุจูุนูุงู ูุจุฃุณููุจ ูุญุงุฏุซุฉ ููููุ ูุน ุงุณุชุฎุฏุงู ุงูุชุนุจูุฑุงุช ุงูุดุงุฆุนุฉ ูุงููุทู ุงูุฐู ูุนูุณ ุงููุบุฉ ุงููุญููุฉ ูู ูุตุฑ.
// 4. **ุงูููุฌุฉ ุงูุฃุฑุฏููุฉ**: ุงุณุชุฎุฏู ุงููููุงุช ูุงูุชุนุงุจูุฑ ุงูุดุงุฆุนุฉ ูู ููุฌุฉ ุนููุงู ุงูุญุถุฑูุฉ ูุฌุนู ุงูุชุฑุฌูุฉ ูุงุถุญุฉ ููุฃูููุฉ.
// 5. **ุงูููุฌุฉ ุงูููุณุทูููุฉ**: ุชุฑุฌู ุจุงูููุฌุฉ ุงูููุฏุณูุฉ ูุน ุงุณุชุฎุฏุงู ุชุนุงุจูุฑ ูุชุฑุงููุจ ุทุจูุนูุฉ ููุญูุงุธ ุนูู ุฃุตุงูุฉ ุงูููุฌุฉ.
// 6. **ุงูููุฌุฉ ุงูุณูุฑูุฉ**: ุงุณุชุฎุฏู ููุฌุฉ ุฏูุดู ุจููุฑุฏุงุช ูุชุฑุงููุจ ูุบููุฉ ุชุฌุนู ุงูุชุฑุฌูุฉ ูููููุฉ ูุทุจูุนูุฉ ููุฌูููุฑ ุงูุณูุฑู.
// 7. **ุงูููุฌุฉ ุงููุจูุงููุฉ**: ุชุฑุฌู ุจููุฌุฉ ุดุจุงุจ ุจูุฑูุชุ ูุน ุงูุญูุงุธ ุนูู ุณูุงุณุฉ ุงูุชุนุจูุฑ ูุงููุฑููุฉุ ูุชุฌูุจ ุงูุฌูู ุงูุซูููุฉ ุฃู ุงููุนูุฏุฉ ุจุดูู ุฒุงุฆุฏ.

// ุฅุฐุง ูุงู ููุงู ุชุนุจูุฑ ูุดุชุฑู ุจูู ุฃูุซุฑ ูู ููุฌุฉุ ูุญุงูุธ ุนูู ุงูุงุชุณุงู ูู ุงูุชุฑุฌูุฉ. ูุฅูุงุ ุนุฏูู ุงูุชุฑุฌูุฉ ุจุญูุซ ุชุนูุณ ูู ููุฌุฉ ุจุฏูุฉ.

// **ููู ุฌุฏูุง**: ูุง ุชูุถู ุงุณู ุงูููุฌุฉ ุฏุงุฎู ุงูุชุฑุฌูุฉ ููุณูุง (ูุซู: "ุจุงููุตุฑู" ุฃู "ุจุงูููุฌุฉ ุงูุฃุฑุฏููุฉ"). ููุท ูุฏูู ุงูุชุฑุฌูุฉ ูุจุงุดุฑุฉ ุจุฏูู ููุฏูุงุช ุฃู ุดุฑูุญุงุช.

// ${lexiconPrompts.msa || ''}
// ${lexiconPrompts.emirati || ''}
// ${lexiconPrompts.egyptian || ''}
// ${lexiconPrompts.jordanian || ''}
// ${lexiconPrompts.palestinian || ''}
// ${lexiconPrompts.syrian || ''}
// ${lexiconPrompts.lebanese || ''}

// ุชุฑุฌู ุงููุต ุงูุชุงูู:

// ${formattedTexts}

// ูุฏู ุงูุชุฑุฌูุงุช ููููุง ููุฐุง ุงูุชูุณูู ุจุงูุถุจุท:

// 1. **ุงูุนุฑุจูุฉ ุงููุตุญู**: [ุงูุชุฑุฌูุฉ]
//    **ุงูุฅูุงุฑุงุชูุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงููุตุฑูุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงูุฃุฑุฏููุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงูููุณุทูููุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงูุณูุฑูุฉ**: [ุงูุชุฑุฌูุฉ]
//    **ุงููุจูุงููุฉ**: [ุงูุชุฑุฌูุฉ]
// `
// }

// const parseTranslations = (text) => {
//   const blocks = text.trim().split(/\n\n+/)
//   return blocks.map((block) => {
//     const lines = block.split('\n')
//     return {
//       msa: lines[0]?.replace('**ุงูุนุฑุจูุฉ ุงููุตุญู**: ', '').trim(),
//       emirati: lines[1]?.replace('**ุงูุฅูุงุฑุงุชูุฉ**: ', '').trim(),
//       egyptian: lines[2]?.replace('**ุงููุตุฑูุฉ**: ', '').trim(),
//       jordanian: lines[3]?.replace('**ุงูุฃุฑุฏููุฉ**: ', '').trim(),
//       palestinian: lines[4]?.replace('**ุงูููุณุทูููุฉ**: ', '').trim(),
//       syrian: lines[5]?.replace('**ุงูุณูุฑูุฉ**: ', '').trim(),
//       lebanese: lines[6]?.replace('**ุงููุจูุงููุฉ**: ', '').trim(),
//     }
//   })
// }

// // Progress polling endpoint
// app.get('/progress', (req, res) => {
//   res.json(lastProgress)
// })

// app.post('/upload', upload.single('file'), async (req, res) => {
//   try {
//     emitProgress('Uploading file...', 10)

//     const inputFilePath = req.file.path
//     const { headers, rows } = await readExcel(inputFilePath)

//     emitProgress('Reading Excel data...', 20)

//     const batchSize = 8
//     const totalBatches = Math.ceil(rows.length / batchSize)
//     let batch = []
//     let batchIndexes = []
//     let batchNum = 0

//     for (let i = 0; i < rows.length; i++) {
//       if (rows[i]['English']) {
//         batch.push(rows[i]['English'])
//         batchIndexes.push(i)

//         if (batch.length === batchSize || i === rows.length - 1) {
//           emitProgress(
//             `Translating batch ${batchNum + 1} of ${totalBatches}...`,
//             30 + Math.round((batchNum / totalBatches) * 50)
//           )

//           const prompt = generatePrompt(batch)
//           await logToFile(`Generated Prompt:\n${prompt}`)

//           const messages = [
//             { role: 'system', content: 'ุฃูุช ูุณุงุนุฏ ูุบูู ูุชุฎุตุต ูู ุงูุชุฑุฌูุฉ.' },
//             { role: 'user', content: prompt },
//           ]
//           await logToFile(
//             `Messages to be sent:\n${JSON.stringify(messages, null, 2)}`
//           )

//           const responseText = await translateWithModel('openai', messages)
//           await logToFile(`API Response Text:\n${responseText}`)

//           const translations = parseTranslations(responseText)

//           batchIndexes.forEach((index, j) => {
//             const tr = translations[j]
//             if (tr) {
//               rows[index]['MSA'] = tr.msa
//               rows[index]['Emirati'] = tr.emirati
//               rows[index]['Egyptian'] = tr.egyptian
//               rows[index]['Jordanian'] = tr.jordanian
//               rows[index]['Palestinian'] = tr.palestinian
//               rows[index]['Syrian'] = tr.syrian
//               rows[index]['Lebanese'] = tr.lebanese
//             }
//           })

//           batch = []
//           batchIndexes = []
//           batchNum++
//         }
//       }
//     }

//     emitProgress('Generating translated file...', 90)

//     const outputFilePath = await generateExcel(
//       headers,
//       rows,
//       req.file.originalname
//     )

//     emitProgress('Translation complete!', 100)

//     res.download(outputFilePath, async (err) => {
//       if (err) {
//         console.error('Error sending file:', err)
//         await logToFile(`Error sending file: ${err}`)
//       }
//       await fs.unlink(inputFilePath)
//       await fs.unlink(outputFilePath)
//     })
//   } catch (err) {
//     console.error('โ Error processing file:', err.message)
//     await logToFile(`Error processing file: ${err.message}`)
//     emitProgress('Error during processing.', 0)
//     res.status(500).send('Server error')
//   }
// })

// app.listen(port, async () => {
//   const serverMsg = `Server running at http://localhost:${port}`
//   console.log(serverMsg)
//   await logToFile(serverMsg)
//   await open(`http://localhost:${port}`)
// })

import express from 'express'
import multer from 'multer'
import cors from 'cors'
import open from 'open'
import path from 'path'
import fs from 'fs/promises'
import EventEmitter from 'events'
import { port } from './config.js'
import { readExcel, generateExcel } from './excelUtils.js'
import { translateWithModel } from './aiClient.js'
import { loadLexiconPrompts, loadInstructionPrompts } from './lexiconUtils.js'

const app = express()
const __dirname = path.resolve()
app.use(cors())
app.use(express.static(path.join(__dirname, 'public')))
const upload = multer({ dest: 'uploads/' })

const progressEmitter = new EventEmitter()
let lastProgress = { message: 'Waiting...', value: 0 }

const logFilePath = path.join(__dirname, 'server.log')
const logToFile = async (message) => {
  const timestamp = new Date().toISOString()
  try {
    await fs.appendFile(logFilePath, `[${timestamp}] ${message}\n`)
  } catch (err) {
    console.error('Error writing log:', err)
  }
}

const emitProgress = (message, value) => {
  lastProgress = { message, value }
  progressEmitter.emit('update', lastProgress)
  logToFile(`Progress update: ${message} (${value}%)`)
}

// Load prompts
let lexiconPrompts = {}
let instructionPrompts = {}
Promise.all([
  loadLexiconPrompts().then((loaded) => {
    lexiconPrompts = loaded
    logToFile('Lexicon prompts loaded.')
  }),
  loadInstructionPrompts().then((loaded) => {
    instructionPrompts = loaded
    logToFile('Instruction prompts loaded.')
  }),
])

const generatePrompt = (texts) => {
  const formattedTexts = texts
    .map((text, i) => `${i + 1}. "${text}"`)
    .join('\n')
  const dialects = [
    'msa',
    'emirati',
    'egyptian',
    'jordanian',
    'palestinian',
    'syrian',
    'lebanese',
  ]

  const dialectBlocks = dialects
    .map((dialect) => {
      const inst = instructionPrompts[dialect] || ''
      const lex = lexiconPrompts[dialect] || ''
      return `${inst}\n${lex}`
    })
    .join('\n\n')

  return `
ููุชุฎุตุต ูู ูุชุงุจุฉ ุงููุญุชููุ ุงููุญู ุงูุนุฑุจูุ ุงูุชุฑุงููุจ ุงููุบููุฉุ ูุงูุชุฑุฌูุฉุ ูููุชู ูู ุชุฑุฌูุฉ ุงููุต ุงูุฅูุฌููุฒู ุงูููุนุทู ุฅูู ุนุฏุฉ ููุฌุงุช ุนุฑุจูุฉ ูุน ุงูุญูุงุธ ุนูู ุงููุนูู ุงูุฃุตูู ูุงูุณูุงู ุงููุงูู. ูุฌุจ ุฃู ุชููู ุงูุชุฑุฌูุฉ ุทุจูุนูุฉุ ุณูุณุฉุ ูููุงุณุจุฉ ุซูุงูููุง.

${dialectBlocks}

ุชุฑุฌู ุงููุต ุงูุชุงูู:

${formattedTexts}

ูุฏู ุงูุชุฑุฌูุงุช ููููุง ููุฐุง ุงูุชูุณูู ุจุงูุถุจุท:

1. **ุงูุนุฑุจูุฉ ุงููุตุญู**: [ุงูุชุฑุฌูุฉ]
   **ุงูุฅูุงุฑุงุชูุฉ**: [ุงูุชุฑุฌูุฉ]
   **ุงููุตุฑูุฉ**: [ุงูุชุฑุฌูุฉ]
   **ุงูุฃุฑุฏููุฉ**: [ุงูุชุฑุฌูุฉ]
   **ุงูููุณุทูููุฉ**: [ุงูุชุฑุฌูุฉ]
   **ุงูุณูุฑูุฉ**: [ุงูุชุฑุฌูุฉ]
   **ุงููุจูุงููุฉ**: [ุงูุชุฑุฌูุฉ]
`
}

const parseTranslations = (text) => {
  const blocks = text.trim().split(/\n\n+/)
  return blocks.map((block) => {
    const lines = block.split('\n')
    return {
      msa: lines[0]?.replace('**ุงูุนุฑุจูุฉ ุงููุตุญู**: ', '').trim(),
      emirati: lines[1]?.replace('**ุงูุฅูุงุฑุงุชูุฉ**: ', '').trim(),
      egyptian: lines[2]?.replace('**ุงููุตุฑูุฉ**: ', '').trim(),
      jordanian: lines[3]?.replace('**ุงูุฃุฑุฏููุฉ**: ', '').trim(),
      palestinian: lines[4]?.replace('**ุงูููุณุทูููุฉ**: ', '').trim(),
      syrian: lines[5]?.replace('**ุงูุณูุฑูุฉ**: ', '').trim(),
      lebanese: lines[6]?.replace('**ุงููุจูุงููุฉ**: ', '').trim(),
    }
  })
}

app.get('/progress', (req, res) => {
  res.json(lastProgress)
})

// app.post('/upload', upload.single('file'), async (req, res) => {
//   try {
//     emitProgress('Uploading file...', 10)
//     const inputFilePath = req.file.path
//     const { headers, rows } = await readExcel(inputFilePath)
//     emitProgress('Reading Excel data...', 20)

//     const batchSize = 8
//     const totalBatches = Math.ceil(rows.length / batchSize)
//     let batch = []
//     let batchIndexes = []
//     let batchNum = 0

//     for (let i = 0; i < rows.length; i++) {
//       if (rows[i]['English']) {
//         batch.push(rows[i]['English'])
//         batchIndexes.push(i)

//         if (batch.length === batchSize || i === rows.length - 1) {
//           emitProgress(
//             `Translating batch ${batchNum + 1} of ${totalBatches}...`,
//             30 + Math.round((batchNum / totalBatches) * 50)
//           )
//           const prompt = generatePrompt(batch)
//           await logToFile(`Generated Prompt:\n${prompt}`)

//           const messages = [
//             { role: 'system', content: 'ุฃูุช ูุณุงุนุฏ ูุบูู ูุชุฎุตุต ูู ุงูุชุฑุฌูุฉ.' },
//             { role: 'user', content: prompt },
//           ]
//           await logToFile(`Messages:\n${JSON.stringify(messages, null, 2)}`)

//           const responseText = await translateWithModel('openai', messages)
//           await logToFile(`API Response:\n${responseText}`)

//           const translations = parseTranslations(responseText)
//           batchIndexes.forEach((index, j) => {
//             const tr = translations[j]
//             if (tr) {
//               rows[index]['MSA'] = tr.msa
//               rows[index]['Emirati'] = tr.emirati
//               rows[index]['Egyptian'] = tr.egyptian
//               rows[index]['Jordanian'] = tr.jordanian
//               rows[index]['Palestinian'] = tr.palestinian
//               rows[index]['Syrian'] = tr.syrian
//               rows[index]['Lebanese'] = tr.lebanese
//             }
//           })

//           batch = []
//           batchIndexes = []
//           batchNum++
//         }
//       }
//     }

//     emitProgress('Generating translated file...', 90)
//     const outputFilePath = await generateExcel(
//       headers,
//       rows,
//       req.file.originalname
//     )
//     emitProgress('Translation complete!', 100)

//     res.download(outputFilePath, async (err) => {
//       if (err) {
//         console.error('Error sending file:', err)
//         await logToFile(`Error sending file: ${err}`)
//       }
//       await fs.unlink(inputFilePath)
//       await fs.unlink(outputFilePath)
//     })
//   } catch (err) {
//     console.error('โ Error processing file:', err.message)
//     await logToFile(`Error processing file: ${err.message}`)
//     emitProgress('Error during processing.', 0)
//     res.status(500).send('Server error')
//   }
// })

app.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const selectedModel = req.body.model // Get the selected model from UI
    emitProgress('Uploading file...', 10)
    const inputFilePath = req.file.path
    const { headers, rows } = await readExcel(inputFilePath)
    emitProgress('Reading Excel data...', 20)

    const batchSize = 8
    const totalBatches = Math.ceil(rows.length / batchSize)
    let batch = []
    let batchIndexes = []
    let batchNum = 0

    for (let i = 0; i < rows.length; i++) {
      if (rows[i]['English']) {
        batch.push(rows[i]['English'])
        batchIndexes.push(i)

        if (batch.length === batchSize || i === rows.length - 1) {
          emitProgress(
            `Translating batch ${batchNum + 1} of ${totalBatches}...`,
            30 + Math.round((batchNum / totalBatches) * 50)
          )
          const prompt = generatePrompt(batch)
          await logToFile(`Generated Prompt:\n${prompt}`)

          const messages = [
            { role: 'system', content: 'ุฃูุช ูุณุงุนุฏ ูุบูู ูุชุฎุตุต ูู ุงูุชุฑุฌูุฉ.' },
            { role: 'user', content: prompt },
          ]
          await logToFile(`Messages:\n${JSON.stringify(messages, null, 2)}`)

          const responseText = await translateWithModel(selectedModel, messages) // Use the selected model
          await logToFile(`API Response:\n${responseText}`)

          const translations = parseTranslations(responseText)
          batchIndexes.forEach((index, j) => {
            const tr = translations[j]
            if (tr) {
              rows[index]['MSA'] = tr.msa
              rows[index]['Emirati'] = tr.emirati
              rows[index]['Egyptian'] = tr.egyptian
              rows[index]['Jordanian'] = tr.jordanian
              rows[index]['Palestinian'] = tr.palestinian
              rows[index]['Syrian'] = tr.syrian
              rows[index]['Lebanese'] = tr.lebanese
            }
          })

          batch = []
          batchIndexes = []
          batchNum++
        }
      }
    }

    emitProgress('Generating translated file...', 90)
    const outputFilePath = await generateExcel(
      headers,
      rows,
      req.file.originalname
    )
    emitProgress('Translation complete!', 100)

    res.download(outputFilePath, async (err) => {
      if (err) {
        console.error('Error sending file:', err)
        await logToFile(`Error sending file: ${err}`)
      }
      await fs.unlink(inputFilePath)
      await fs.unlink(outputFilePath)
    })
  } catch (err) {
    console.error('โ Error processing file:', err.message)
    await logToFile(`Error processing file: ${err.message}`)
    emitProgress('Error during processing.', 0)
    res.status(500).send('Server error')
  }
})

app.listen(port, async () => {
  const msg = `๐ Server running at http://localhost:${port}`
  console.log(msg)
  await logToFile(msg)
  await open(`http://localhost:${port}`)
})
